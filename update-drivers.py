#!/usr/bin/env -S python -u
"""
# Dependencies:
pip install pyyaml requests pydantic
"""


import argparse
import enum
import json
import logging
import os
import re
import sys
import tempfile
import time
from collections.abc import Sequence
from pathlib import Path
from urllib.parse import urljoin

import requests
import yaml
from pydantic import BaseModel, Field, validator

RESOURCES_BASE_PATH = 'apps'
CI_KUSTOMIZATION_FILE_NAME = 'ci.yaml'
CI_KUSTOMIZATION_HEADER = """# Do not edit this file manually.
# It is managed by payment-tests automation script.
"""
# Required environment variables
KUBE_TOKEN = os.environ['GITOPS_KUBE_TOKEN']
KUBE_CERT = os.environ['GITOPS_KUBE_CERT']
KUBE_BASE_URL = os.environ['GITOPS_KUBE_BASE_URL']

KUSTOMIZATION_TEMPLATE = """
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: {name}
spec:
  values:
    image:
      tag: {tag}
    env:
      X_UPDATE: {serial}
"""

DO_NOT_ADD_POSTFIX = object()

DRIVER_POSTFIX_MAP = {
    'fields-mock': DO_NOT_ADD_POSTFIX,
}


class EnumMeta(enum.EnumMeta):
    def __contains__(cls, item):
        try:
            cls(item)
        except ValueError:
            return False
        else:
            return True


class StrEnum(str, enum.Enum, metaclass=EnumMeta):
    def __str__(self):
        return self.value

    def __repr__(self):
        return str(self)


class Namespace(StrEnum):
    PSP = 'psp'


class Action(StrEnum):
    UPDATE = 'update'
    REVERT = 'revert'
    WAIT_REDEPLOY = 'wait'


TAG_ANY_VERSION = 'any'

LOGGER = logging.getLogger('update-drivers')


def _noop(v):
    return v


def format_psp_resource_name(driver_name):
    """driver1 -> psp-driver-postfix."""
    postfix = DRIVER_POSTFIX_MAP.get(driver_name, 'postfix')
    if postfix is DO_NOT_ADD_POSTFIX:
        postfix = ''
    else:
        postfix = f'-{postfix}'
    return f'psp-{driver_name}{postfix}'


def get_resource_names(resources_dir) -> list[str]:
    exclude = ('kustomization.yaml', 'ci.yaml')
    paths = [
        p for p in Path(resources_dir).glob('*.yaml') if p.name not in exclude
    ]

    names = []
    for yaml_path in paths:
        with open(yaml_path) as fp:
            parsed = yaml.safe_load(fp)
            names.append(parsed['metadata']['name'])

    return names


def _format_resource(name, tag, serial):
    return KUSTOMIZATION_TEMPLATE.format(name=name, tag=tag, serial=serial)


def format_resources(resources_names, tag, serial):
    formatted_resources = [
        _format_resource(name, tag, serial) for name in resources_names
    ]
    return '---'.join(formatted_resources)


def _check_resources_exist(resources_dir, resources_names):
    all_resources_names = get_resource_names(resources_dir)
    unknown_resources = [
        name for name in resources_names if name not in all_resources_names
    ]
    if unknown_resources:
        raise KeyError(
            f'Unknown drivers: {unknown_resources}, possible values:'
            f' {all_resources_names}',
        )


# Actions


def make_ci_kustomization(resources_dir, tag, namespace, resources_names=None):
    if resources_names:
        _check_resources_exist(resources_dir, resources_names)
    else:
        resources_names = get_resource_names(resources_dir)

    serial = int(time.time())
    kustomizations = format_resources(resources_names, tag, serial)

    kustomizations_path = Path(resources_dir) / CI_KUSTOMIZATION_FILE_NAME
    kustomizations_path.write_text(CI_KUSTOMIZATION_HEADER + kustomizations)


def revert_ci_kustomization(resources_dir):
    kustomizations_path = Path(resources_dir) / CI_KUSTOMIZATION_FILE_NAME
    kustomizations_path.write_text(CI_KUSTOMIZATION_HEADER)


def wait_ci_kustomization_to_apply(
    namespace,
    tag,
    resources_dir,
    resources_names,
):
    resources_names = resources_names or get_resource_names(resources_dir)
    total_drivers = len(resources_names)
    LOGGER.info(
        'waiting for %s driver(s):\n%s',
        total_drivers,
        '\n'.join(resources_names),
    )
    kube_api = KubeAPI(
        namespace,
        token=KUBE_TOKEN,
        client_cert=KUBE_CERT,
        base_url=KUBE_BASE_URL,
    )

    updated = []
    for event in kube_api.stream_changes(resources_names):
        container = event.pod.first_matching_container(resources_names)
        if (
            (tag == TAG_ANY_VERSION or container.version == tag)
            and event.pod.is_ready
            and event.pod.name not in updated
        ):
            updated.append(event.pod.name)
            yield total_drivers, len(updated), event.pod.name
        # TODO: add max timeout
        if len(updated) == len(resources_names):
            break


# Kube API


class KubePod(BaseModel):
    kube_status: dict = Field(None, alias='status')
    kube_metadata: dict = Field(None, alias='metadata')
    kube_spec: dict = Field(None, alias='spec')

    @property
    def status(self):
        return self.kube_status['phase']

    @property
    def name(self):
        pod_labels = self.kube_metadata['labels']
        name_label = 'app.kubernetes.io/name'
        return pod_labels.get(name_label, '')

    @property
    def containers(self):
        return [KubeContainer(**c) for c in self.kube_spec['containers']]

    def first_matching_container(self, must_match: list[str]):
        return [c for c in self.containers if c.name in must_match].pop()

    @property
    def conditions(self):
        return [
            KubeCondition(**c) for c in self.kube_status.get('conditions', [])
        ]

    @property
    def is_ready(self):
        conditions = [
            c
            for c in self.conditions
            if c.type == KubeConditionStatus.ContainersReady and c.status
        ]
        return bool(conditions)


class KubeContainer(BaseModel):
    name: str
    image: str

    @property
    def version(self):
        return self.image.split(':')[1]


class KubeChangeType(StrEnum):
    MODIFIED = 'MODIFIED'


class KubePodStatus(StrEnum):
    Running = 'Running'


class KubeConditionStatus(StrEnum):
    ContainersReady = 'ContainersReady'


class KubeCondition(BaseModel):
    type: str
    status: bool

    @validator('status', pre=True)
    def convert_status(cls, v):
        return True if v == 'True' else False


class KubeChange(BaseModel):
    type: str
    pod: KubePod = Field(alias='object')

    class Config:
        arbitrary_types_allowed = True


class KubeAPI:
    def __init__(self, namespace, token, client_cert, base_url):
        self.token = token
        self.client_cert = client_cert
        self.base_url = base_url

        self.namespace = namespace
        self.url = urljoin(
            self.base_url,
            f'/api/v1/namespaces/{self.namespace}/pods',
        )
        # deleted on script termination
        self.ca_cert = tempfile.NamedTemporaryFile()
        self._write_cert()
        self.headers = {'Authorization': f'Bearer {self.token}'}

    def _write_cert(self):
        prefix = '-----BEGIN CERTIFICATE-----'
        suffix = '-----END CERTIFICATE-----'
        if not self.client_cert.startswith(prefix):
            self.client_cert = f'{prefix}\n{self.client_cert}\n{suffix}'
        self.ca_cert.file.write(self.client_cert.encode())
        self.ca_cert.file.flush()

    def _request_params(self):
        return {
            'headers': self.headers,
            'verify': self.ca_cert.name,
        }

    def _stream_changes(self, filter_fn=None):
        init_resp = requests.get(self.url, **self._request_params())
        data = init_resp.json()
        try:
            start_version = data['metadata']['resourceVersion']
        except KeyError:
            LOGGER.error('Could not get resource version: %s', data)
            raise

        watch_resp = requests.get(
            self.url,
            params={'watch': 1, 'resourceVersion': start_version},
            stream=True,
            **self._request_params(),
        )
        filter_fn = filter_fn or _noop
        for line in watch_resp.iter_lines():
            if line:
                decoded_line = line.decode('utf-8')
                changed = json.loads(decoded_line)
                event = KubeChange(**changed)
                if filter_fn(event):
                    yield event

    def stream_changes(self, filter_for_pods: Sequence[str]):
        def filter_pods(event: KubeChange):
            """See for details:

            https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/  # noqa: E501
            """

            if event.type != KubeChangeType.MODIFIED:
                return

            if event.pod.name in filter_for_pods:
                return event

        yield from self._stream_changes(filter_pods)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('action', choices=Action)
    parser.add_argument('namespace', choices=Namespace)
    parser.add_argument(
        '--drivers',
        help='update only theese drivers',
    )
    parser.add_argument('--tag', default='master')
    parser.add_argument('--env', default='staging')

    return parser.parse_args()


def main():
    args = parse_args()
    resources_dir = Path(RESOURCES_BASE_PATH) / args.env / args.namespace
    if args.drivers and args.drivers != 'all':
        drivers = [name.strip() for name in re.split(r',|\s', args.drivers)]
        drivers = [name for name in drivers if name]
        if args.namespace == Namespace.PSP:
            drivers = [format_psp_resource_name(name) for name in drivers]
    else:
        drivers = None

    if args.action == Action.REVERT:
        revert_ci_kustomization(resources_dir)

    elif args.action == Action.UPDATE:
        make_ci_kustomization(resources_dir, args.tag, args.namespace, drivers)

    elif args.action == Action.WAIT_REDEPLOY:
        LOGGER.info('waiting for kustomization to apply using k8s API')
        for (
            total_drivers,
            updated_drivers,
            driver,
        ) in wait_ci_kustomization_to_apply(
            args.namespace,
            args.tag,
            resources_dir,
            drivers,
        ):
            LOGGER.info(
                f'[{updated_drivers}/{total_drivers}]'
                f' {args.namespace}/{driver} has been updated to {args.tag}',
            )
        LOGGER.info('All drivers have been updated successfully')


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    main()
